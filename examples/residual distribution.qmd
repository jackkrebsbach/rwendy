---
title: "residual distribution"
format: html
---

```{r}
library(deSolve)
library(symengine)
library(trust)
library(uGMAR)
library(trustOptim)
```

```{r}
setwd("..")
source("./R/noise.R")
source("./R/symbolics.R")
source("./R/test_functions.R")
source("./R/weak_residual.R")
source("./R/wendy.R")
```

## Logistic

```{r}
f <- function(u, p, t) {
  c(p[1] * u[1] - p[2] * u[1]^2)
}

noise_sd <- 0.05;
p_star <- c(1, 1);
u0 <- c(0.01);
p0 <- c(0.5, 0.5);
npoints <- 200;
t_span <- c(0.005, 10);
t_eval <- seq(t_span[1], t_span[2], length.out = npoints);

modelODE <- function(tvec, state, parameters) { list(as.vector(f(state, parameters, tvec))) }
sol <- deSolve::ode(y = u0, times = t_eval, func = modelODE, parms = p_star)

# Additive Gaussian Noise
U <- matrix(c(sol[, 2] + rnorm(npoints, mean = 0, sd = noise_sd)), ncol = 1)
tt <- matrix(sol[, 1], ncol = 1)

res <- solveWendy(f, p0, U, tt, method = "IRLS", optimize = F, compute_svd = T)

g <- res$g
G <- res$G
b <- res$b
b1 <- res$b1

p_hat <- solve(t(G) %*% G, t(G) %*% b1)
#p_hat <- p_star

r <- (G %*% p_hat) - b1

covR <- res$S(p_hat)
eig <- eigen(covR, symmetric = TRUE)
r_w <- eig$vectors %*% diag(1/sqrt(eig$values)) %*% t(eig$vectors) %*% r


dens_r   <- density(r)
dens_rw  <- density(r_w)

cols <- brewer.pal(4, "Set1")

plot(dens_r, main="Logistic: OLS vs IRLS Residuals", xlab="Residual value", ylab="Density", lwd=2, col=cols[1], xlim=c(-5,5))
lines(dens_rw, col=cols[2], lwd=2, lty=4)
curve(dnorm(x, mean=0, sd=1), add=TRUE, col=cols[3], lwd=2)
legend("topright", legend=c("OLS Residuals", "IRLS Residuals", "Standard Normal"), col=cols[1:3], lwd=2)
```

## Lorenz

```{r}
f <- function(u, p, t) {
  du1 <- p[1] * (u[2] - u[1])
  du2 <- u[1] * (p[2] - u[3]) - u[2]
  du3 <- u[1] * u[2] - p[3] * u[3]
  c(du1, du2, du3)
}

noise_sd <- 0.005
p_star <- c(10.0, 28.0, 8.0 / 3.0)
p0 <- c(12.0, 21, 4.0)
u0 <- c(2, 1, 1)
npoints <- 256
t_span <- c(0, 10)
t_eval <- seq(t_span[1], t_span[2], length.out = npoints)

modelODE <- function(tvec, state, parameters) { list(as.vector(f(state, parameters, tvec))) }

sol <- deSolve::ode(y = u0, times = t_eval, func = modelODE, parms = p_star)

noise <- matrix(
  rnorm(nrow(sol) * (ncol(sol) - 1), mean = 0, sd = noise_sd),
  nrow = nrow(sol)
)

# Additive Gaussian
U <- sol[, -1] + noise
tt <- matrix(sol[, 1], ncol = 1)

res <- solveWendy(f, p0, U, tt, method = "IRLS", optimize = F)

g <- res$g
G <- res$G
b <- res$b
b1 <- res$b1

p_hat <- solve(t(G) %*% G, t(G) %*% b1)

r <- (G %*% p_hat) - b1

covR <- res$S(p_hat)
eig <- eigen(covR, symmetric = TRUE)
r_w <- eig$vectors %*% diag(1/sqrt(eig$values)) %*% t(eig$vectors) %*% r

dens_r   <- density(r)
dens_rw  <- density(r_w)

cols <- brewer.pal(4, "Set1")

plot(dens_r, main="Lorenz: OLS vs IRLS Residuals", xlab="Residual value", ylab="Density", lwd=2, col=cols[1], xlim=c(-5,5))
lines(dens_rw, col=cols[2], lwd=2, lty=4)
curve(dnorm(x, mean=0, sd=1), add=TRUE, col=cols[3], lwd=2)
legend("topright", legend=c("OLS Residuals", "IRLS Residuals", "Standard Normal"), col=cols[1:3], lwd=2)
```
